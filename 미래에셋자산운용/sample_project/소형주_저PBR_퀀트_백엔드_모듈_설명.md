# 소형주 저PBR 퀀트 백엔드 모듈 상세 설명서

본 문서는 `소형주_저PBR_퀀트_백엔드_모듈.py` 코드의 구조, 로직 및 활용된 기술에 대해 상세하게 설명합니다. 이 모듈은 퀀트 투자 전략을 백테스팅하고 분석하기 위한 객체 지향 프로토타입입니다.

---

## 1. 개요 및 핵심 아키텍처

이 모듈은 데이터 수집부터 시뮬레이션, 결과 분석 및 시각화까지의 전 과정을 자동화한 **퀀트 백테스팅 파이프라인**입니다. 코드의 유지보수성과 확장성을 위해 기능을 크게 세 개의 클래스로 분리하여 설계했습니다.

- **`DataPipeline`**: 데이터 수집 및 전처리 (ETL)
- **`QuantStrategy`**: 투자 아이디어의 시그널화 (Logic)
- **`BacktestEngine`**: 시뮬레이션 및 성과 분석 (Analysis)

---

## 2. 상세 구성 요소 설명

### 2.1. 로깅 및 환경 설정 (Line 10-19)
- **Logging**: `logging` 모듈을 사용하여 실행 과정(수집, 시그널 생성, 완료 등)을 기록합니다. 이는 단순 `print`보다 실무적인 백엔드 운영에 적합합니다.
- **Font Setting**: MacOS(`AppleGothic`)와 Windows(`Malgun Gothic`)를 자동 감지하여 Matplotlib 그래프에서 한글이 깨지지 않도록 설정합니다.

### 2.2. DataPipeline 클래스 (Line 21-62)
데이터의 입력(Input)을 담당합니다.
- **`fetch_market_data()`**: `FinanceDataReader` 라이브러리를 통해 KRX(한국거래소)의 실시간 종목 리스트를 가져옵니다.
- **`fetch_historical_prices()`**: 특정 종목의 과거 주가를 API로부터 직접 수집합니다. (백테스팅 비교군 생성 시 활용)
- **`load_historical_financials()`**: 로컬 CSV 파일(`fin_statement_new.csv`)을 읽어옵니다. 
  - **데이터 정제**: CSV 내의 복잡한 컬럼명(예: `P/B(Adj., FY End)`)을 `PBR`, `Price` 등 다루기 쉬운 이름으로 변경합니다.

### 2.3. QuantStrategy 클래스 (Line 54-77)
투자 전략의 '두뇌' 역할을 하며, 어떤 종목을 살지 결정합니다.
- **필터링 로직**:
  1. **소형주 선정**: `groupby('year')`와 `quantile(0.2)`를 결합하여 매년 시가총액 하위 20%에 해당하는 종목을 골라냅니다.
  2. **저PBR 선정**: 소형주 중 PBR이 낮은 순서대로 상위 20개를 추출합니다.
  3. **안전 장치**: 데이터 오류나 극단적 부실주를 방지하기 위해 PBR이 0.2 미만인 종목은 제외합니다.
- **시그널 생성**: `pivot`과 `notna()`를 활용해 **연도 x 종목** 형태의 Boolean(True/False) 매트릭스를 반환합니다.

### 2.4. BacktestEngine 클래스 (Line 79-130)
생성된 시그널을 바탕으로 실제 수익률을 계산합니다.
- **벡터화 연산 (Vectorization)**: `(returns_df * self.signal_df.astype(int)).mean(axis=1)` 코드는 반복문 없이 수만 개의 데이터를 행렬 연산으로 한 번에 처리하여 속도가 매우 빠릅니다.
- **데이터 정렬 (Alignment)**: Pandas의 특징을 활용해 시그널 데이터와 가격 데이터의 날짜/종목을 자동으로 매칭합니다.
- **성과 지표 계산**:
  - **CAGR**: 연평균 성장률
  - **MDD**: 최대 낙폭 (위험 측정)
  - **Sharpe Ratio**: 위험 대비 수익성

---

## 3. 백테스팅 전략: "소형주 + 저PBR"

본 모듈이 구현하고 있는 전략은 한국 시장에서 역사적으로 높은 성과를 보였던 **가치 투자(Value Investing)** 전략입니다.

| 항목 | 내용 |
| :--- | :--- |
| **유니버스** | 코스피, 코스닥 전체 종목 |
| **핵심 팩터** | 시가총액(하위 20%), PBR(낮을수록 우수) |
| **종목 수** | 연간 20개 |
| **리밸런싱** | 매년 1회 종목 교체 (Buy & Hold 1년) |

---

## 4. 실행 흐름 (main 함수)

1. **초기화**: `DataPipeline` 객체 생성 및 데이터 로드.
2. **시그널 생성**: `QuantStrategy`를 통해 연도별 매수 종목 확정.
3. **시뮬레이션**: `BacktestEngine`에 가격 데이터와 시그널을 주입하여 실행.
4. **리포팅**: 콘솔에 CAGR, MDD 등 주요 지표 출력.
5. **시각화**: `Matplotlib`을 통해 누적 수익률 추이 그래프 출력.

---

## 5. 결과 그래프 해석 방법

- **X축 (Year)**: 투자 연도 (2005년 ~ 종료 시점)
- **Y축 (Cumulative Return)**: 원금 1.0 기준의 누적 수익 변화.
  - 예: Y축이 **2.5**라면 원금 대비 **150% 수익** (2.5배 자산)을 의미합니다.
- **빨간 점선**: 원금 선(1.0). 이 선보다 높으면 수익, 낮으면 손실 상태입니다.
- **텍스트 박스**: 좌측 상단에 현재 적용된 전략의 핵심 조건이 명시되어 있어 분석 결과의 신뢰도를 높여줍니다.

---

## 6. API 데이터 vs 로컬 CSV 데이터 활용 가이드

사용자는 "과거 데이터도 API로 직접 가져오면 안 되나?"라는 의문을 가질 수 있습니다. 기술적인 관점에서의 가이드는 다음과 같습니다.

### 6.1. API 직접 호출이 유리한 경우 (FinanceDataReader)
- **최신성**: 오늘 자 종목 리스트, 어제의 종가 등 가장 따끈따끈한 데이터가 필요할 때.
- **특정 종목 분석**: 삼성전자, SK하이닉스 등 몇몇 종목의 상세 주가 시계열이 필요할 때.

### 6.2. 로컬 CSV/DB 활용이 유리한 경우 (본 모듈 방식)
- **대량의 재무 지표**: 백테스팅에는 수천 개 종목의 10년 치 PBR, PER, 시가총액 등이 필요합니다. 이를 API로 매번 호출하면 네트워크 속도 문제로 수 시간이 걸릴 수 있으며, API 제공처의 트래픽 제한에 걸릴 위험이 큽니다.
- **데이터 일관성**: 과거 재무 데이터는 수정되는 경우가 거의 없으므로, 한 번 정제된 데이터를 로컬에 두고 사용하는 것이 속도와 안정성 면에서 압도적으로 유리합니다. (퀀트 백엔드 설계의 일반적인 원칙)

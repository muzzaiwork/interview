# 04. 예상 질문 및 답변

## 📋 일반 면접 질문
- **자기소개 (지원동기 통합형)**: 
  - **전략**: "빠른 결과보다는 **'한 치의 오차도 없는 정확한 결과'**를 선호하는 본인의 차분한 성향을 강조하며, 이것이 왜 자산운용 플랫폼 엔지니어링의 정수와 일치하는지를 설명합니다."
  - **예시 문구**: "반갑습니다. 저는 대규모 금융 데이터를 다루며 '숫자에 대한 신뢰'를 구축해 온 백엔드 엔지니어입니다. 
    저는 스스로를 빠르게 무언가를 쳐내기보다, 시간이 조금 더 걸리더라도 단 하나의 오차 없이 완벽한 결과를 만들어내는 데 더 큰 보람을 느끼는 사람이라고 생각합니다. 
    이러한 저의 성향은 에잇퍼센트나 블루월넛 같은 PG, P2P 금융권에서 결제와 뱅킹 시스템을 담당하며 더욱 굳건해졌습니다. 수천억 원의 자금이 오가는 정산 과정에서 단 1원의 오차라도 끝까지 추적해 정합성을 맞추고, 데이터의 무결성을 확보하는 일은 저에게 가장 즐겁고 몰입할 수 있는 업무였습니다.
    미래에셋자산운용의 플랫폼 엔지니어 포지션 공고를 보았을 때, 제가 가장 잘할 수 있고 또 깊이 몰입할 수 있는 최적의 무대라는 확신이 들었습니다. 방대한 시계열 데이터와 복잡한 퀀트 로직이 얽힌 이 플랫폼에서, 저의 차분하고 꼼꼼한 성향을 바탕으로 가장 신뢰할 수 있는 데이터 파운데이션을 구축하고자 지원하게 되었습니다."
- **이직 사유 (전략적 답변 가이드)**: 
  - **상황**: 에잇퍼센트, 티맥스핀테크, 블루월넛 모두 희망퇴직으로 인한 퇴사.
  - **답변 전략**: "회사의 경영 상황이나 조직 개편 등 외부 환경 요인(희망퇴직)은 간략히 언급하되, 이를 **'기술적 열망을 실현할 더 넓은 무대를 찾는 계기'**로 승화시키는 것이 핵심입니다."
  - **예시 문구**: "지난 세 번의 이직은 모두 회사의 비즈니스 상황 변화에 따른 희망퇴직이라는 공통된 배경이 있었습니다. 저는 이 과정들을 거치며, 단순히 기능을 구현하는 것을 넘어 **'어떤 환경에서도 지속 가능하고 강력한 인프라를 구축하는 플랫폼 엔지니어링'**의 중요성을 뼈저리게 느꼈습니다. 
    특히 금융 도메인에서의 풍부한 경험을 바탕으로, 이제는 외부 풍파에 흔들리지 않는 **미래에셋자산운용**이라는 견고한 플랫폼 위에서 제가 가진 21억 건의 데이터 처리 역량과 분산 연산 기술을 쏟아붓고 싶어 지원하게 되었습니다."
- **지원 동기**: (왜 미래에셋자산운용인가?)
- **본인의 장단점 (신뢰와 품질 중심)**: 
  - **장점 (신뢰와 협업)**: "저의 가장 큰 장점은 **'데이터에 대한 높은 신뢰도'**와 **'불화를 만들지 않는 차분한 협업 태도'**입니다. PG사와 P2P 금융권에서 정산 시스템을 담당하며, 단 1원의 오차도 허용하지 않는 정합성을 유지해 왔습니다. 또한, 의견 충돌이 발생할 때 감정적으로 대응하기보다 차분하게 원인을 분석하고 데이터와 논리로 설득하며 원만한 해결점을 찾아내는 데 능숙합니다. 동료들로부터 '함께 일할 때 가장 든든하고 신뢰할 수 있는 사람'이라는 평가를 받는 것이 저의 가장 큰 자산입니다."
  - **단점 (신뢰와 품질을 위한 속도 조절)**: "상대적으로 '빠르게 쳐내야 하는 업무'보다는 '시간이 걸리더라도 완벽하게 해내야 하는 업무'에 더 강점이 있습니다. 때로는 하나에 깊이 몰입하다 보니 속도가 다소 더디게 느껴질 때도 있습니다. 이를 보완하기 위해 **업무 시작 전 우선순위를 명확히 설정**하고, 반복되는 검증 로직은 **자동화 테스트로 구축**하여 품질을 유지하면서도 전체적인 속도를 높이려 노력하고 있습니다."
- **성취 경험**: (가장 큰 성과를 냈던 사례)
- **갈등 해결**: (팀 내 의견 충돌 시 해결 방법)

## 💻 기술 및 실무 질문 (예상)

### 1. 언어 핵심 역량 (Java vs Python)

**Q: Java와 Python의 핵심적인 차이와, 자산운용 플랫폼에서 각각 어떤 역할을 수행하기에 적합하다고 생각하시나요?**

> **A:** "Java는 **정적 타이핑과 컴파일 기반** 언어로, 대규모 시스템의 안정성과 성능이 중요한 **코어 백엔드(주문, 체결, 정산 등)**에 적합합니다. 반면 Python은 **동적 타이핑과 풍부한 라이브러리**를 갖춘 인터프리터 언어로, **데이터 분석, 전략 백테스팅, AI 모델 학습** 등 빠른 프로토타이핑과 유연한 연산이 필요한 영역에 탁월합니다. 플랫폼 엔지니어링 관점에서는 이 두 언어의 장점을 결합하여 '안정적인 인프라(Java) 위에서 유연한 연산(Python)'이 가능한 아키텍처를 구축하는 것이 중요하다고 생각합니다."

#### ☕ Java 관련 (안정성 및 고성능 연산)
- **왜 Java가 Python보다 속도가 빠른가요?**:
  - "Java가 Python보다 빠른 이유는 크게 3가지 기술적 특징 때문입니다.
    1) **JIT(Just-In-Time) 컴파일러**: Java는 바이트코드를 실행하는 도중에 자주 사용되는 코드를 기계어로 직접 컴파일하여 캐싱합니다. 처음에는 인터프리터처럼 동작하지만, 시간이 지날수록(Warm-up) C++에 육박하는 속도를 냅니다.
    2) **정적 타이핑 (Static Typing)**: 컴파일 시점에 변수 타입이 확정되므로, 실행 시점에 타입 체크를 할 필요가 없어 CPU 연산 최적화가 가능합니다.
    3) **효율적인 메모리 레이아웃**: Java의 원시 타입(Primitive types: int, double 등)은 Python 객체보다 메모리 구조가 훨씬 단순하고 직접적이어서 데이터 처리 속도가 빠릅니다."
- **JVM과 GC(Garbage Collection)**: "Java의 가장 큰 특징은 JVM 위에서 동작하여 OS 독립적이라는 점과, GC를 통해 메모리를 자동으로 관리한다는 점입니다. 특히 대규모 트랜잭션 처리 시 STW(Stop-The-World) 시간을 최소화하기 위해 G1GC나 ZGC 같은 적절한 GC 알고리즘을 선택하고 튜닝하는 역량이 중요합니다."
- **멀티스레딩 (Concurrency)**: "Java는 강력한 멀티스레딩 모델을 제공합니다. `ExecutorService`나 최근의 `Virtual Threads` 등을 활용하여 수많은 동시 요청을 효율적으로 처리할 수 있습니다. 이는 실시간 시세 처리나 대량의 주문 인터페이스 구축 시 핵심적인 역할을 합니다."
- **Spring Boot 프레임워크**: "기업용 애플리케이션 개발의 표준으로, 다양한 라이브러리와의 통합이 쉽고 테스트 자동화가 용이합니다. 특히 MSA 구조에서 서비스 간 통신이나 트랜잭션 관리에 매우 강력합니다."

#### 🐍 Python 관련 (데이터 분석 및 생산성)
- **왜 Python은 Java나 C++보다 속도가 느린가요?**: 
  - "Python이 상대적으로 느린 이유는 크게 4가지입니다. 
    1) **인터프리터 언어**: 컴파일 단계 없이 실행 시점에 코드를 해석하므로 오버헤드가 큽니다. 
    2) **동적 타이핑(Dynamic Typing)**: 변수의 타입을 실행 시점에 결정하므로 매번 타입 체크를 수행해야 합니다. 
    3) **GIL(Global Interpreter Lock)**: 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있어 멀티코어 활용이 제한적입니다. 
    4) **모든 것이 객체(Object)**: 단순 숫자 하나도 객체로 처리되어 메모리 할당과 참조 과정이 복잡합니다."
- **그럼에도 행렬 연산은 Python이 Java보다 빠르다고 할 수 있나요?**:
  - "**순수 Python** 코드로 루프를 돌리면 Java보다 훨씬 느립니다. 하지만 **Numpy나 Pandas**를 사용하면 Java와 대등하거나 심지어 더 빠를 수 있습니다.
    1) **C-Extension**: Numpy 연산은 내부적으로 고도로 최적화된 **C, C++, Fortran** 코드를 호출합니다. 사실상 Python은 명령만 내릴 뿐 실제 연산은 컴파일 언어가 수행합니다.
    2) **SIMD(Single Instruction Multiple Data)**: Numpy는 CPU의 특수 연산 기능을 활용해 한 번의 명령으로 여러 데이터를 동시에 처리(Vectorization)합니다. 
    3) **메모리 인접성**: Python 객체와 달리 Numpy 배열은 메모리에 연속적으로 배치되어 CPU 캐시 효율이 극대화됩니다. 
    따라서 퀀트 플랫폼의 '대규모 행렬 연산'은 Python 라이브러리를 통해 개발 속도와 실행 속도를 모두 잡을 수 있습니다."
- **플랫폼 엔지니어링에서 Python의 성능 한계를 극복하는 방법**:
  - "**Numpy나 Pandas** 같은 라이브러리를 활용합니다. 이들은 내부적으로 C/C++로 구현되어 있어 행렬 연산 시 컴파일 언어 수준의 속도를 냅니다. 
  - CPU 연산이 많은 작업은 `multiprocessing`이나 **Ray/Dask** 클러스터를 활용해 병렬/분산 처리로 해결합니다. 
  - 성능이 극도로 중요한 로직은 **Cython**이나 **Pybind11**을 통해 C++ 모듈로 작성하여 Python에서 호출하는 방식을 사용합니다."
- **GIL (Global Interpreter Lock)**: "Python의 메모리 관리(Reference Counting)를 안전하게 유지하기 위한 장치입니다. I/O Bound 작업(네트워크 호출 등)에서는 큰 문제가 없으나, CPU Bound 작업에서는 병목이 됩니다. 이를 위해 앞서 말씀드린 멀티프로세싱이나 분산 연산 프레임워크를 전략적으로 선택하는 것이 엔지니어의 핵심 역량입니다."
- **덕 타이핑 (Duck Typing) & 동적 타입**: "코드가 간결하고 읽기 쉬워 연구원(Quant)과 엔지니어 간의 협업에 유리합니다. 다만 런타임 에러 방지를 위해 `Type Hinting`과 철저한 유닛 테스트가 동반되어야 플랫폼의 안정성을 유지할 수 있습니다."
- **강력한 데이터 생태계**: "Pandas, Numpy, Scikit-learn 등 이미 검증된 수학/통계 라이브러리가 풍부하여, 복잡한 퀀트 로직을 가장 적은 코드로 구현할 수 있는 언어입니다."

### 2. 시스템 설계 및 인프라
- **데이터 파이프라인**: "데이터 정합성을 유지하면서 효율적으로 대용량 데이터를 처리하는 전략은?"
- **데이터 저장소**: "백테스팅을 위한 대규모 시계열 데이터를 저장하고 엔진으로 전달할 때, DB와 파일 시스템 중 어떤 방식을 선호하며 그 이유는 무엇인가요?"
- **인프라**: "Kubernetes 환경에서 서비스 모니터링 및 트러블슈팅 경험이 있는가?"
- **AI/ML**: "ML 모델 서빙 시 지연 시간(Latency)을 최소화하기 위한 방법은?"
- **도메인**: "자산운용 분야에서 데이터 플랫폼이 왜 중요하다고 생각하는가?"

## 📂 이력서 및 자소서 기반 질문

### 1. 기술적 도전과 해결
- **[에잇퍼센트]**: 21억 건에 달하는 데이터를 어떻게 분석하여 중복을 찾아내고, 중기적으로 10억 건 이하로 줄이셨나요? (데이터 이관 시 정합성 유지 방법)
- **[페이레터]**: 해외 20여 개 PG를 연동하며 가장 힘들었던 지역이나 사례는 무엇이었으며, 어떻게 극복했나요?
- **[티맥스핀테크]**: '금융 상품 팩토리' 설계 시 MDD 프레임워크와 유사한 구조를 선택한 이유는 무엇이며, 어떤 유연성을 확보했나요?
- **[블루월넛]**: SVN에서 Git으로 CI/CD 환경을 이관하면서 팀원들의 반대나 기술적 장애는 없었나요?

### 2. 업무 프로세스 및 협업
- 기획/재무 파트의 요구사항을 ERD로 설계하는 과정에서 가장 중요하게 생각하는 원칙은 무엇인가요?
- 시각 자료(플로우차트, 시퀀스 다이어그램)를 활용한 소통의 장점을 실제 사례를 들어 설명해 주세요.
- 결제 내역 대사(모니터링) 프로그램 개발 시, 불일치가 발생했을 때의 자동화된 처리 프로세스가 있나요?

### 3. 직무 적합성 (Mirae Asset)
- **본인의 결제/여신 시스템 경험이 자산운용 플랫폼 개발에 어떤 도움이 될까요?**
  - "금융 서비스의 본질은 '숫자에 대한 신뢰'라고 생각합니다. 21억 건의 데이터를 다루며 정합성을 맞춘 경험과 글로벌 PG 연동 시 발생한 다양한 예외 상황 해결 능력은, 한 치의 오차도 허용되지 않는 퀀트 백테스팅 엔진과 데이터 파이프라인의 안정성을 높이는 데 핵심적인 역할을 할 것입니다."
- **제공된 '소형주 저PBR' 샘플 코드에서 개선하고 싶은 점이 있다면?**
  - "현재는 싱글 스레드 기반의 로컬 실행 구조입니다. 이를 Platform Engineering 팀의 목적에 맞게 고도화한다면, 첫째로 **분산 처리 엔진**으로 확장하여 수백 개의 전략을 동시 백테스팅할 수 있게 하고, 둘째로 데이터 수집 단계를 **Airflow와 같은 워크플로우 도구**를 통해 자동화하고 싶습니다. 또한, `Pandas` 연산 중 병목이 발생하는 지점은 `C++`이나 `Golang` 모듈로 대체하여 성능을 최적화할 수 있습니다."
- **퀀트 백테스팅 엔진에서 가장 중요하게 생각하는 기술적 요소는 무엇인가요?**
  - "데이터의 **시점 정렬(Alignment)**과 **벡터화 연산(Vectorization)**입니다. 샘플 코드에서도 보셨듯이, 시그널과 수익률 행렬의 인덱스를 일치시키는 작업이 정확하지 않으면 'Look-ahead bias' 같은 치명적인 오류가 발생합니다. 저는 대규모 DB 리팩토링 경험을 통해 데이터 구조 설계 시 이러한 정합성을 확보하는 데 강점이 있습니다."

### 3. 디자인 패턴 및 설계 역량 (Deep Dive)
- **상환 스케줄 계산 로직을 개선할 때 왜 Strategy 패턴을 선택하셨나요?**
  - "당시 80개가 넘는 상환 방식이 존재했고, 이를 조건문으로 처리하면 코드 응집도가 낮아지고 확장성이 떨어지는 '클래스 폭발' 문제가 명확했습니다. Strategy 패턴을 통해 각 계산 로직을 독립적인 전략으로 캡슐화하고, 필요에 따라 교체 가능하게 함으로써 OCP(개방 폐쇄 원칙)를 지키고자 했습니다."
- **Strategy 패턴과 Factory 패턴을 함께 사용한 이유는 무엇인가요?**
  - "Strategy 패턴은 '어떻게' 계산할지를 정의하지만, '어떤' 전략을 사용할지 결정하는 책임은 별도로 분리해야 합니다. Factory 패턴을 도입하여 비즈니스 로직에서 전략 생성 로직을 분리함으로써 객체 생성의 책임을 단일화하고 클라이언트 코드의 결합도를 낮췄습니다."
- **퀀트 플랫폼 설계 시 이러한 디자인 패턴을 어떻게 적용할 수 있을까요?**
  - "퀀트 엔진은 수많은 지표(Factor)와 매매 전략의 조합입니다. 각 팩터 계산 로직과 전략 시그널 생성 로직을 Strategy로 추상화하고, 설정값에 따라 적절한 객체를 생성하는 Factory를 구축한다면, 새로운 전략을 추가할 때 기존 엔진 코드를 전혀 손대지 않고도 유연하게 확장할 수 있습니다."

### 4. 기타 및 가치관 관련 (자소서 기반)
- **성장 과정**: "정확한 결과를 선호하는 성향"이 실무에서 어떻게 긍정적인 영향을 끼쳤는지 사례를 들어 설명해 주세요.
- **협업**: 팀 프로젝트에서 리더 역할을 수행할 때, 팀원 간의 의견 차이를 어떻게 조율했나요?
- **퀀트 프로젝트**: 개인적으로 구현한 퀀트 파이프라인에서 가장 구현하기 어려웠던 부분은 무엇이며, 데이터 정합성을 위해 어떤 검증 로직을 넣었나요?
- **신뢰 확보**: 정산 파트너로부터 차기 프로젝트에서도 동일 파트너로 계약을 이어갈 만큼 신뢰를 얻은 비결은 무엇인가요?
